<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Haunanz</title>
        <link>https://haunanz.github.io/</link>
        <description>Haunanz</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 18 Nov 2020 19:20:18 &#43;0800</lastBuildDate>
            <atom:link href="https://haunanz.github.io/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>经典同步问题Go语言实现</title>
    <link>https://haunanz.github.io/posts/2020.11/%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</link>
    <pubDate>Wed, 18 Nov 2020 19:20:18 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://haunanz.github.io/posts/2020.11/%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</guid>
    <description><![CDATA[引言 并发编程中各个并发实例有许多的制约关系，为了协调各个实例的制约关系，引入了同步的概念。 下面了解几个经典的同步问题： 生产者消费者问题 读写者]]></description>
</item><item>
    <title>同时处理TCP和UDP</title>
    <link>https://haunanz.github.io/posts/note/%E5%90%8C%E6%97%B6%E5%A4%84%E7%90%86tcp%E5%92%8Cudp/</link>
    <pubDate>Mon, 26 Oct 2020 22:08:10 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://haunanz.github.io/posts/note/%E5%90%8C%E6%97%B6%E5%A4%84%E7%90%86tcp%E5%92%8Cudp/</guid>
    <description><![CDATA[正文 面试常见题，是否可以在一个linux的网络端口同时处理TCP和UDP。 常间的同时处理TCP和UDP的程序有超级服务inetd 和安卓的调试]]></description>
</item><item>
    <title>为什么使用动态内存</title>
    <link>https://haunanz.github.io/posts/note/1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</link>
    <pubDate>Wed, 21 Oct 2020 22:48:38 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://haunanz.github.io/posts/note/1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</guid>
    <description><![CDATA[如果在编码时就可以确定作用域和所需内存大小，那么动态内存就没有必要使用。 但是在实际的生产中，对于复杂的系统来说，内存的大小总是不可估计的。 下]]></description>
</item><item>
    <title>Go笔记 切片截断导致内存泄露</title>
    <link>https://haunanz.github.io/posts/2020.9/go%E7%AC%94%E8%AE%B0-%E5%88%87%E7%89%87%E6%88%AA%E6%96%AD%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E4%B8%8D%E8%83%BD%E9%87%8A%E6%94%BE/</link>
    <pubDate>Sat, 26 Sep 2020 20:11:40 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://haunanz.github.io/posts/2020.9/go%E7%AC%94%E8%AE%B0-%E5%88%87%E7%89%87%E6%88%AA%E6%96%AD%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E4%B8%8D%E8%83%BD%E9%87%8A%E6%94%BE/</guid>
    <description><![CDATA[引言 go与语言在使用切片截断时，底层数组没有改变，依然持有指向堆内存的指针，导致内存无法释放。 // 示例 type Node [100]byte data := []*Node{} for i:=10; i&lt;10; i++ { tmp := &amp;Node{} data = append(data,tmp) } data =]]></description>
</item><item>
    <title>Go原始套接字编程</title>
    <link>https://haunanz.github.io/posts/2020.9/go%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</link>
    <pubDate>Tue, 01 Sep 2020 21:56:19 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://haunanz.github.io/posts/2020.9/go%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</guid>
    <description><![CDATA[引言 请注意，本文档的运行环境是Linux。 在Windows环境下注意系统调用的接口有差别。 两个计算机如何在网络中定位彼此的位置呢？计算机中的]]></description>
</item><item>
    <title>Go语言Linux网络编程-使用原始套接字 </title>
    <link>https://haunanz.github.io/posts/2020.9/go%E8%AF%AD%E8%A8%80linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E4%BD%BF%E7%94%A8syscall/</link>
    <pubDate>Sun, 30 Aug 2020 10:06:16 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://haunanz.github.io/posts/2020.9/go%E8%AF%AD%E8%A8%80linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E4%BD%BF%E7%94%A8syscall/</guid>
    <description><![CDATA[Go语言直接使用原始套接字编写网络程序。 想使用Go学习网络编程，但大多是教程都是从套接字开始讲起。但是GO提供了net包，屏蔽了底层的复杂性]]></description>
</item></channel>
</rss>
